<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hex Planet - Dual Geodesic Wireframe</title>
    <style>
        html, body { margin: 0; padding: 0; height: 100%; overflow: hidden; background: #000; }
        canvas { display: block; }
        .info { position: absolute; top: 10px; width: 100%; text-align: center; color: #fff; font-family: system-ui, sans-serif; pointer-events: none; }
        .ui {
            position: absolute; left: 16px; bottom: 16px; z-index: 10;
            background: rgba(255,255,255,0.9); color: #111; padding: 12px 14px;
            border-radius: 10px; font-family: system-ui, sans-serif; box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }
        .ui label { font-size: 12px; color: #444; display: block; margin-bottom: 6px; }
        .ui input[type=range] { width: 240px; }
        .value { font-weight: 700; }
    </style>
</head>
<body>
    <div class="info">Drag to Rotate, Scroll to Zoom</div>
    <div class="ui">
        <label>Tile density (detail): <span class="value" id="detailValue">5</span></label>
        <input type="range" id="detail" min="0" max="20" step="1" value="5" />
        <label style="margin-top:10px">Continents: <span class="value" id="continentsValue">6</span></label>
        <input type="range" id="continents" min="3" max="24" step="1" value="6" />
        <label style="margin-top:10px">Sea level: <span class="value" id="seaValue">0.45</span></label>
        <input type="range" id="sea" min="0" max="1" step="0.01" value="0.45" />
        <label style="margin-top:10px">Noise: <span class="value" id="noiseValue">1.2</span></label>
        <input type="range" id="noise" min="0" max="3" step="0.05" value="1.2" />
        <div style="margin-top:10px; display:flex; gap:8px; align-items:center;">
            <button id="regen" style="padding:6px 10px; border-radius:6px; border:1px solid #ccc; background:#fff; cursor:pointer;">Regenerate</button>
            <span id="seedLbl" class="value"></span>
        </div>
    </div>

    <!-- Three.js and controls (non-module for easy file:// usage) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 32);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; controls.dampingFactor = 0.08;

        const ambient = new THREE.AmbientLight(0xffffff, 0.35); scene.add(ambient);
        const dir = new THREE.DirectionalLight(0xffffff, 0.9); dir.position.set(20, 30, 10); scene.add(dir);

        const radius = 15;
        let solidSphere = null;
        let wireframe = null;
        let tileGroup = null; // holds colored tiles
        let lastDetail = 5;

        // biome settings with seed
        const settings = {
            continents: 6,
            seaLevel: 0.45,
            noiseAmp: 1.2,
            seed: Math.floor(Math.random() * 1e9)
        };

        function setSeedLabel() {
            document.getElementById('seedLbl').textContent = `seed:${settings.seed}`;
        }

        // simple seeded PRNG (xorshift32)
        function makeRng(seed) {
            let x = seed >>> 0;
            return function() { x ^= x << 13; x ^= x >>> 17; x ^= x << 5; return ((x >>> 0) / 4294967296); };
        }

        function randomUnitVector(rng) {
            const z = rng() * 2 - 1;
            const t = rng() * Math.PI * 2;
            const r = Math.sqrt(1 - z*z);
            return new THREE.Vector3(r*Math.cos(t), z, r*Math.sin(t)).normalize();
        }

        // cheap value noise based on dot products
        function hash3(x, y, z) {
            return (Math.sin(x*12.9898 + y*78.233 + z*45.164 + settings.seed*0.0001) * 43758.5453) % 1;
        }
        function noise3(v, scale) {
            const s = scale || 1;
            return 0.5 + 0.5 * Math.sin((v.x*s)*2.1 + Math.sin((v.y*s)*2.3 + (v.z*s)*2.5));
        }
        function fbm(v, scale, octaves) {
            let a = 0; let f = 1; let amp = 0.5;
            for (let i=0;i<octaves;i++) { a += amp * noise3(v.clone().multiplyScalar(scale*f)); f *= 2; amp *= 0.5; }
            return a;
        }

        function shade(color, factor) {
            const r = Math.max(0, Math.min(255, Math.floor(((color >> 16) & 255) * factor)));
            const g = Math.max(0, Math.min(255, Math.floor(((color >> 8) & 255) * factor)));
            const b = Math.max(0, Math.min(255, Math.floor((color & 255) * factor)));
            return (r << 16) | (g << 8) | b;
        }

        function disposeObject(obj) {
            if (!obj) return;
            obj.traverse?.(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (Array.isArray(child.material)) child.material.forEach(m => m.dispose());
                    else child.material.dispose();
                }
            });
            scene.remove(obj);
        }

        function buildPlanet(detail) {
            // Clean previous
            disposeObject(solidSphere); disposeObject(wireframe); disposeObject(tileGroup);

            // Base icosahedron
            const geom = new THREE.IcosahedronGeometry(radius, detail);

            // Solid base (dark)
            // Slightly smaller solid so tiles sit above it
            const baseGeom = geom.clone();
            baseGeom.scale(0.995, 0.995, 0.995);
            solidSphere = new THREE.Mesh(baseGeom, new THREE.MeshPhongMaterial({ color: 0x0d1020, shininess: 10, specular: 0x0f0f0f }));
            scene.add(solidSphere);

            // Build dual wireframe from face centroids
            const vertices = [];
            const pos = geom.attributes.position;
            for (let i = 0; i < pos.count; i++) vertices.push(new THREE.Vector3().fromBufferAttribute(pos, i));

            const faces = [];
            if (geom.index) {
                for (let i = 0; i < geom.index.count; i += 3) {
                    faces.push({ a: geom.index.getX(i), b: geom.index.getX(i + 1), c: geom.index.getX(i + 2) });
                }
            } else {
                for (let i = 0; i < pos.count; i += 3) faces.push({ a: i, b: i + 1, c: i + 2 });
            }

            // Face centroids
            const centroids = faces.map(f => new THREE.Vector3().add(vertices[f.a]).add(vertices[f.b]).add(vertices[f.c]).divideScalar(3).normalize().multiplyScalar(radius * 1.0005));

            const key = v => `${v.x.toFixed(6)}_${v.y.toFixed(6)}_${v.z.toFixed(6)}`;
            const edgeToFaces = new Map();
            faces.forEach((f, idx) => {
                [[f.a, f.b], [f.b, f.c], [f.c, f.a]].forEach(([iA, iB]) => {
                    const k1 = key(vertices[iA]); const k2 = key(vertices[iB]);
                    const ek = k1 < k2 ? `${k1}|${k2}` : `${k2}|${k1}`;
                    if (!edgeToFaces.has(ek)) edgeToFaces.set(ek, []);
                    edgeToFaces.get(ek).push(idx);
                });
            });

            const linePoints = [];
            for (const pair of edgeToFaces.values()) {
                if (pair.length === 2) {
                    linePoints.push(centroids[pair[0]].clone(), centroids[pair[1]].clone());
                }
            }

            const wireGeom = new THREE.BufferGeometry().setFromPoints(linePoints);
            const wireMat = new THREE.LineBasicMaterial({ color: 0x6aa3ff, linewidth: 1, transparent: true, opacity: 0.35 });
            wireframe = new THREE.LineSegments(wireGeom, wireMat);
            // wireframe will be added AFTER tiles so it sits on top with translucency

            // Dispose original geom (we cloned for solid)
            geom.dispose();

            // Build filled tiles with biome colors (dual polygon fans)
            tileGroup = new THREE.Group();
            const vertexToFaces = new Map();
            faces.forEach((face, faceIndex) => {
                [face.a, face.b, face.c].forEach(vi => {
                    if (!vertexToFaces.has(vi)) vertexToFaces.set(vi, []);
                    vertexToFaces.get(vi).push(faceIndex);
                });
            });

            // Continents seeds
            const rng = makeRng(settings.seed);
            const seeds = Array.from({length: settings.continents}, () => randomUnitVector(rng));
            const wind = new THREE.Vector3(0.7, 0.0, -0.3).normalize();

            function elevationAt(n) {
                // plate distance (nearest seed)
                let minD = 2;
                for (const s of seeds) { const d = 1 - n.dot(s); if (d < minD) minD = d; }
                // Stronger continental signal
                let base = 1 - (minD / 2);
                base = Math.pow(base, 1.25); // sharpen continents
                // Noise detail
                const ridges = Math.abs(0.5 - fbm(n, 6.0, 3)) * 2.0; // 0..1 ridges
                const nois = fbm(n, 2.5, 4) * settings.noiseAmp * 0.35 + ridges * 0.15;
                let h = base * 0.8 + nois;
                return Math.max(0, Math.min(1, h));
            }

            function biomeColor(n) {
                const elev = elevationAt(n);
                if (elev < settings.seaLevel) return 0x0b3d91; // ocean deep
                const lat = Math.abs(n.y);
                let temp = 1 - Math.pow(lat, 1.35) - elev*0.5; // lapse rate stronger
                temp = Math.max(0, Math.min(1, temp));
                const moist = Math.max(0, Math.min(1, 0.55*fbm(n, 1.8, 3) + 0.45*Math.max(0, n.dot(wind))))
                               * (0.9 + 0.3*(1-elev));
                // Elevation bands
                if (elev > settings.seaLevel + 0.42) return 0xd4d8db; // high mountain light
                if (elev > settings.seaLevel + 0.34) return 0x8b7355; // mountain
                // Temperature/Moisture biomes (high-contrast palette)
                if (temp < 0.15) return 0xf5f9ff; // ice
                if (temp < 0.3 && moist > 0.5) return 0xb7d3f2; // cold wet (taiga snow)
                if (moist < 0.2 && temp > 0.35) return 0xd9b36f; // desert
                if (moist < 0.4) return 0x9dc183; // steppe/grassland
                if (moist < 0.65) return 0x3e8744; // forest
                return 0x1b5e20; // rainforest dark
            }

            vertices.forEach((vertex, vi) => {
                const adj = vertexToFaces.get(vi) || [];
                if (adj.length < 5) return; // need at least a pentagon
                const center = vertex.clone().normalize();
                const up = center.clone();
                let right = new THREE.Vector3(1,0,0).cross(up).normalize();
                if (right.length() < 0.1) right = new THREE.Vector3(0,1,0).cross(up).normalize();
                const forward = up.clone().cross(right).normalize();
                const ordered = adj.map(idx => ({ idx, c: centroids[idx] }))
                    .sort((A,B)=>{
                        const a = A.c.clone().sub(center).normalize();
                        const b = B.c.clone().sub(center).normalize();
                        const angA = Math.atan2(a.dot(forward), a.dot(right));
                        const angB = Math.atan2(b.dot(forward), b.dot(right));
                        return angA-angB;
                    });
                const boundary = ordered.map(o => o.c.clone().normalize());
                // Build triangle fan
                const pos = [];
                const nrm = [];
                // Elevation-based extrusion for clear relief
                const elev = elevationAt(center);
                let extrude = (elev - settings.seaLevel);
                extrude = Math.max(-0.015, Math.min(0.06, extrude * 0.12));
                const C = center.clone().multiplyScalar(radius*(1.0002 + extrude));
                for (let i=0;i<boundary.length;i++) {
                    const P = boundary[i].clone().multiplyScalar(radius*(1.0002 + extrude));
                    const N = boundary[(i+1)%boundary.length].clone().multiplyScalar(radius*(1.0002 + extrude));
                    pos.push(C.x,C.y,C.z, P.x,P.y,P.z, N.x,N.y,N.z);
                    nrm.push(center.x,center.y,center.z, boundary[i].x,boundary[i].y,boundary[i].z,
                             boundary[(i+1)%boundary.length].x,boundary[(i+1)%boundary.length].y,boundary[(i+1)%boundary.length].z);
                }
                const g = new THREE.BufferGeometry();
                g.setAttribute('position', new THREE.Float32BufferAttribute(pos,3));
                g.setAttribute('normal', new THREE.Float32BufferAttribute(nrm,3));
                let col = biomeColor(center);
                // slight shading by elevation
                col = shade(col, 0.9 + extrude*2);
                const mat = new THREE.MeshLambertMaterial({ color: col, flatShading: true, polygonOffset: true, polygonOffsetFactor: 1, polygonOffsetUnits: 1 });
                const m = new THREE.Mesh(g, mat);
                tileGroup.add(m);

                // Outline for visual definition
                const loopPts = [];
                for (let i=0;i<boundary.length;i++) loopPts.push(boundary[i].clone().multiplyScalar(radius*(1.00022 + extrude)));
                const outlineGeom = new THREE.BufferGeometry().setFromPoints(loopPts);
                outlineGeom.setIndex([...Array(loopPts.length).keys()].flatMap((i)=>[i,(i+1)%loopPts.length]));
                // Coastline highlight
                const coast = Math.abs(elev - settings.seaLevel) < 0.02;
                const outlineMat = new THREE.LineBasicMaterial({ color: coast ? 0x88d5ff : 0x0c0f14, linewidth: coast ? 2 : 1 });
                const outline = new THREE.LineSegments(outlineGeom, outlineMat);
                tileGroup.add(outline);
            });
            scene.add(tileGroup);
            scene.add(wireframe);
        }

        // UI
        const detailSlider = document.getElementById('detail');
        const detailValue = document.getElementById('detailValue');
        const continentsSlider = document.getElementById('continents');
        const continentsValue = document.getElementById('continentsValue');
        const seaSlider = document.getElementById('sea');
        const seaValue = document.getElementById('seaValue');
        const noiseSlider = document.getElementById('noise');
        const noiseValue = document.getElementById('noiseValue');
        const regenBtn = document.getElementById('regen');

        function setDetail(val) { detailValue.textContent = val; lastDetail = parseInt(val,10); buildPlanet(lastDetail); }
        function updateAndRebuild() { setSeedLabel(); buildPlanet(lastDetail); }

        detailSlider.addEventListener('input', e => setDetail(e.target.value));
        continentsSlider.addEventListener('input', e => { settings.continents = parseInt(e.target.value,10); continentsValue.textContent = settings.continents; updateAndRebuild(); });
        seaSlider.addEventListener('input', e => { settings.seaLevel = parseFloat(e.target.value); seaValue.textContent = settings.seaLevel.toFixed(2); updateAndRebuild(); });
        noiseSlider.addEventListener('input', e => { settings.noiseAmp = parseFloat(e.target.value); noiseValue.textContent = settings.noiseAmp.toFixed(2); updateAndRebuild(); });
        regenBtn.addEventListener('click', ()=>{ settings.seed = Math.floor(Math.random()*1e9); updateAndRebuild(); });

        // Initial
        setSeedLabel();
        setDetail(detailSlider.value);

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Animate
        (function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        })();
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Geodesic Sphere</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        .info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: sans-serif;
        }
    </style>
</head>
<body>
    <div class="info">Drag to Rotate, Scroll to Zoom</div>

    <!-- Import utility libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // --- 1. Scene, Camera, and Renderer Setup ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 30;
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // --- 2. Create the Sphere Geometry ---
        const radius = 15;
        const detail = 5; // A good balance of detail and performance
        const icosahedronGeometry = new THREE.IcosahedronGeometry(radius, detail);

        // A. Solid base sphere
        const solidMaterial = new THREE.MeshBasicMaterial({ color: 0x1a1a1a });
        const solidSphere = new THREE.Mesh(icosahedronGeometry, solidMaterial);
        scene.add(solidSphere);

        // B. Calculate the dual geometry (hexagonal wireframe)
        const vertices = [];
        const positions = icosahedronGeometry.attributes.position;
        for (let i = 0; i < positions.count; i++) {
            vertices.push(new THREE.Vector3().fromBufferAttribute(positions, i));
        }

        const faces = [];
        if (icosahedronGeometry.index) {
            for (let i = 0; i < icosahedronGeometry.index.count; i += 3) {
                faces.push({ a: icosahedronGeometry.index.getX(i), b: icosahedronGeometry.index.getX(i + 1), c: icosahedronGeometry.index.getX(i + 2) });
            }
        } else {
            for (let i = 0; i < positions.count; i += 3) {
                faces.push({ a: i, b: i + 1, c: i + 2 });
            }
        }

        const faceCentroids = faces.map(face => {
            const vA = vertices[face.a];
            const vB = vertices[face.b];
            const vC = vertices[face.c];
            return new THREE.Vector3().add(vA).add(vB).add(vC).divideScalar(3);
        });

        const getVertexKey = v => `${v.x.toFixed(5)}_${v.y.toFixed(5)}_${v.z.toFixed(5)}`;
        const edgeToFacesMap = new Map();
        faces.forEach((face, i) => {
            const faceEdges = [[vertices[face.a], vertices[face.b]], [vertices[face.b], vertices[face.c]], [vertices[face.c], vertices[face.a]]];
            faceEdges.forEach(edge => {
                const key1 = getVertexKey(edge[0]);
                const key2 = getVertexKey(edge[1]);
                const edgeKey = key1 < key2 ? `${key1}|${key2}` : `${key2}|${key1}`;
                if (!edgeToFacesMap.has(edgeKey)) edgeToFacesMap.set(edgeKey, []);
                edgeToFacesMap.get(edgeKey).push(i);
            });
        });

        const wireframeEdges = [];
        for (const faceIndices of edgeToFacesMap.values()) {
            if (faceIndices.length === 2) {
                const centroid1 = faceCentroids[faceIndices[0]];
                const centroid2 = faceCentroids[faceIndices[1]];
                wireframeEdges.push(centroid1.clone().normalize().multiplyScalar(radius * 1.001));
                wireframeEdges.push(centroid2.clone().normalize().multiplyScalar(radius * 1.001));
            }
        }

        const wireframeGeom = new THREE.BufferGeometry().setFromPoints(wireframeEdges);
        const wireframeMat = new THREE.LineBasicMaterial({ color: 0x888888 });
        const wireframe = new THREE.LineSegments(wireframeGeom, wireframeMat);
        scene.add(wireframe);

        // --- 3. Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // --- 4. Event Listeners ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }, false);

        // --- Start the application ---
        animate();
    </script>
</body>
</html>

