<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hex Planet - Dual Geodesic Wireframe</title>
    <style>
        html, body { margin: 0; padding: 0; height: 100%; overflow: hidden; background: #000; }
        canvas { display: block; }
        .info { position: absolute; top: 10px; width: 100%; text-align: center; color: #fff; font-family: system-ui, sans-serif; pointer-events: none; }
        .ui {
            position: absolute; left: 16px; bottom: 16px; z-index: 10;
            background: rgba(255,255,255,0.9); color: #111; padding: 12px 14px;
            border-radius: 10px; font-family: system-ui, sans-serif; box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }
        .ui label { font-size: 12px; color: #444; display: block; margin-bottom: 6px; }
        .ui input[type=range] { width: 240px; }
        .value { font-weight: 700; }
    </style>
</head>
<body>
    <div class="info">Drag to Rotate, Scroll to Zoom</div>
    <div class="ui">
        <label>Tile density (detail): <span class="value" id="detailValue">16</span></label>
        <input type="range" id="detail" min="0" max="20" step="1" value="16" />
        <label style="margin-top:10px">Continents: <span class="value" id="continentsValue">5</span></label>
        <input type="range" id="continents" min="3" max="24" step="1" value="5" />
        <label style="margin-top:10px">Sea level: <span class="value" id="seaValue">0.80</span></label>
        <input type="range" id="sea" min="0" max="1" step="0.01" value="0.8" />
        <label style="margin-top:10px">Noise: <span class="value" id="noiseValue">0.15</span></label>
        <input type="range" id="noise" min="0" max="3" step="0.05" value="0.15" />
        <label style="margin-top:10px">Mountain Ridges: <span class="value" id="ridgesValue">0.3</span></label>
        <input type="range" id="ridges" min="0" max="1" step="0.05" value="0.3" />
        <label style="margin-top:10px">Outline Alpha: <span class="value" id="alphaValue">0.2</span></label>
        <input type="range" id="alpha" min="0" max="1" step="0.05" value="0.2" />
        <label style="margin-top:10px">Cloud Density: <span class="value" id="cloudDensityValue">0.4</span></label>
        <input type="range" id="cloudDensity" min="0" max="1" step="0.05" value="0.4" />
        <label style="margin-top:10px">Cloud Opacity: <span class="value" id="cloudOpacityValue">0.3</span></label>
        <input type="range" id="cloudOpacity" min="0" max="0.8" step="0.05" value="0.3" />
        <div style="margin-top:10px; display:flex; gap:8px; align-items:center;">
            <button id="regen" style="padding:6px 10px; border-radius:6px; border:1px solid #ccc; background:#fff; cursor:pointer;">Regenerate</button>
            <span id="seedLbl" class="value"></span>
        </div>
        <div style="margin-top:10px;">
            <span class="value" id="zoomInfo">Zoom: 30</span>
        </div>
    </div>

    <!-- Three.js and controls (non-module for easy file:// usage) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>

    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(0, 0, 30);
        const renderer = new THREE.WebGLRenderer({ 
            antialias: true,
            alpha: true,
            powerPreference: "high-performance"
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Better quality on high-DPI displays
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; controls.dampingFactor = 0.08;
        
        // Update zoom display function
        function updateZoomDisplay() {
            const distance = camera.position.distanceTo(controls.target);
            document.getElementById('zoomInfo').textContent = `Zoom: ${distance.toFixed(1)}`;
        }
        
        // Update zoom display when controls change
        controls.addEventListener('change', updateZoomDisplay);

        const ambient = new THREE.AmbientLight(0xffffff, 0.35); scene.add(ambient);
        const dir = new THREE.DirectionalLight(0xffffff, 0.9); dir.position.set(20, 30, 10); scene.add(dir);

        const radius = 15;
        let solidSphere = null;
        let wireframe = null;
        let tileGroup = null; // holds colored tiles
        let cloudSphere = null; // holds the cloud layer
        let lastDetail = 16;
        let cloudAnimationTime = 0;
        
        // Hover system
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let hoveredTile = null;

        // biome settings with seed
        const settings = {
            continents: 5,
            seaLevel: 0.8,
            noiseAmp: 0.15,
            ridgeIntensity: 0.3,
            outlineAlpha: 0.2,
            cloudDensity: 0.4,
            cloudOpacity: 0.3,
            seed: Math.floor(Math.random() * 1e9)
        };
        let simplex = null; // seeded Simplex noise instance

        function setSeedLabel() {
            document.getElementById('seedLbl').textContent = `seed:${settings.seed}`;
        }

        // simple seeded PRNG (xorshift32)
        function makeRng(seed) {
            let x = seed >>> 0;
            return function() { x ^= x << 13; x ^= x >>> 17; x ^= x << 5; return ((x >>> 0) / 4294967296); };
        }

        function randomUnitVector(rng) {
            const z = rng() * 2 - 1;
            const t = rng() * Math.PI * 2;
            const r = Math.sqrt(1 - z*z);
            return new THREE.Vector3(r*Math.cos(t), z, r*Math.sin(t)).normalize();
        }

        // Seeded Simplex noise and fBm
        function noise3(v, scale) {
            const s = scale || 1;
            // simplex returns -1..1; map to 0..1
            return 0.5 + 0.5 * simplex.noise3D(v.x*s, v.y*s, v.z*s);
        }
        function fbm(v, baseScale, octaves) {
            let value = 0;
            let frequency = baseScale;
            let amplitude = 0.5;
            for (let i = 0; i < octaves; i++) {
                value += amplitude * noise3(v, frequency);
                frequency *= 2.0;
                amplitude *= 0.5;
            }
            return value; // 0..1
        }

        // Cloud generation function
        function createCloudSphere() {
            if (cloudSphere) {
                disposeObject(cloudSphere);
                cloudSphere = null;
            }

            if (settings.cloudDensity <= 0 || settings.cloudOpacity <= 0) {
                return; // No clouds if density or opacity is 0
            }

            const cloudRadius = radius * 1.15; // Slightly larger than the planet
            const cloudGeometry = new THREE.SphereGeometry(cloudRadius, 64, 32);
            
            // Create cloud material with custom shader for procedural clouds
            const cloudMaterial = new THREE.ShaderMaterial({
                transparent: true,
                side: THREE.DoubleSide,
                uniforms: {
                    time: { value: 0.0 },
                    cloudDensity: { value: settings.cloudDensity },
                    cloudOpacity: { value: settings.cloudOpacity },
                    seed: { value: settings.seed }
                },
                vertexShader: `
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    
                    void main() {
                        vPosition = position;
                        vNormal = normal;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform float cloudDensity;
                    uniform float cloudOpacity;
                    uniform float seed;
                    
                    varying vec3 vPosition;
                    varying vec3 vNormal;
                    
                    // Simple 3D noise function
                    float hash(vec3 p) {
                        p = fract(p * vec3(443.8975, 397.2973, 491.1871));
                        p += dot(p.zxy, p.yxz + 19.27);
                        return fract(p.x * p.y * p.z);
                    }
                    
                    float noise(vec3 p) {
                        vec3 i = floor(p);
                        vec3 f = fract(p);
                        f = f * f * (3.0 - 2.0 * f);
                        
                        float a = hash(i + vec3(0, 0, 0));
                        float b = hash(i + vec3(1, 0, 0));
                        float c = hash(i + vec3(0, 1, 0));
                        float d = hash(i + vec3(1, 1, 0));
                        float e = hash(i + vec3(0, 0, 1));
                        float f2 = hash(i + vec3(1, 0, 1));
                        float g = hash(i + vec3(0, 1, 1));
                        float h = hash(i + vec3(1, 1, 1));
                        
                        float x1 = mix(a, b, f.x);
                        float x2 = mix(c, d, f.x);
                        float x3 = mix(e, f2, f.x);
                        float x4 = mix(g, h, f.x);
                        
                        float y1 = mix(x1, x2, f.y);
                        float y2 = mix(x3, x4, f.y);
                        
                        return mix(y1, y2, f.z);
                    }
                    
                    float fbm(vec3 p) {
                        float value = 0.0;
                        float amplitude = 0.5;
                        float frequency = 1.0;
                        
                        for(int i = 0; i < 4; i++) {
                            value += amplitude * noise(p * frequency);
                            amplitude *= 0.5;
                            frequency *= 2.0;
                        }
                        return value;
                    }
                    
                    void main() {
                        vec3 pos = normalize(vPosition) + vec3(seed * 0.001);
                        
                        // Create moving clouds with multiple noise layers
                        vec3 cloudPos1 = pos * 3.0 + vec3(time * 0.02, time * 0.01, 0.0);
                        vec3 cloudPos2 = pos * 7.0 + vec3(time * -0.015, time * 0.025, time * 0.01);
                        vec3 cloudPos3 = pos * 15.0 + vec3(time * 0.008, time * -0.012, time * 0.015);
                        
                        float cloud1 = fbm(cloudPos1);
                        float cloud2 = fbm(cloudPos2) * 0.7;
                        float cloud3 = fbm(cloudPos3) * 0.3;
                        
                        float cloudPattern = cloud1 + cloud2 + cloud3;
                        
                        // Apply cloud density threshold
                        float cloudMask = smoothstep(1.0 - cloudDensity, 1.0 - cloudDensity + 0.3, cloudPattern);
                        
                        // Create wispy cloud edges
                        float edgeFade = smoothstep(0.0, 0.4, cloudMask) * smoothstep(1.0, 0.6, cloudMask);
                        
                        // Cloud color - white with slight blue tint
                        vec3 cloudColor = vec3(0.95, 0.97, 1.0);
                        
                        // Fade clouds at viewing angle for realism
                        float viewFade = abs(dot(normalize(vNormal), normalize(vPosition - cameraPosition)));
                        viewFade = smoothstep(0.2, 0.8, viewFade);
                        
                        float finalAlpha = edgeFade * cloudOpacity * viewFade;
                        
                        gl_FragColor = vec4(cloudColor, finalAlpha);
                    }
                `
            });

            cloudSphere = new THREE.Mesh(cloudGeometry, cloudMaterial);
            scene.add(cloudSphere);
        }

        function shade(color, factor) {
            const r = Math.max(0, Math.min(255, Math.floor(((color >> 16) & 255) * factor)));
            const g = Math.max(0, Math.min(255, Math.floor(((color >> 8) & 255) * factor)));
            const b = Math.max(0, Math.min(255, Math.floor((color & 255) * factor)));
            return (r << 16) | (g << 8) | b;
        }

        function disposeObject(obj) {
            if (!obj) return;
            obj.traverse?.(child => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) {
                    if (Array.isArray(child.material)) child.material.forEach(m => m.dispose());
                    else child.material.dispose();
                }
            });
            scene.remove(obj);
        }

        function buildPlanet(detail) {
            console.log('buildPlanet()', { detail, settings: { ...settings } });
            // reseed simplex with current seed to ensure determinism across rebuilds
            simplex = new SimplexNoise(settings.seed.toString());
            
            // Clear hover state
            hoveredTile = null;
            
            // Clean previous
            disposeObject(solidSphere); disposeObject(wireframe); disposeObject(tileGroup); disposeObject(cloudSphere);

            // Base icosahedron
            const geom = new THREE.IcosahedronGeometry(radius, detail);

            // No fallback sphere needed - tiles render directly
            solidSphere = null;

            // Build dual wireframe from face centroids
            const vertices = [];
            const pos = geom.attributes.position;
            for (let i = 0; i < pos.count; i++) vertices.push(new THREE.Vector3().fromBufferAttribute(pos, i));

            // Handle both indexed and non-indexed geometry
        const faces = [];
            if (geom.index) {
                // Indexed geometry - use indices
                for (let i = 0; i < geom.index.count; i += 3) {
                    faces.push({ a: geom.index.getX(i), b: geom.index.getX(i + 1), c: geom.index.getX(i + 2) });
            }
        } else {
                // Non-indexed geometry - build vertex map by comparing positions
                const vertexMap = new Map(); // maps vertex key to index
                const uniqueVertices = [];
                
                for (let i = 0; i < pos.count; i++) {
                    const v = new THREE.Vector3().fromBufferAttribute(pos, i);
                    const key = `${v.x.toFixed(8)}_${v.y.toFixed(8)}_${v.z.toFixed(8)}`;
                    
                    if (!vertexMap.has(key)) {
                        vertexMap.set(key, uniqueVertices.length);
                        uniqueVertices.push(v);
                    }
                }
                
                // Rebuild vertices array with unique vertices
                vertices.length = 0;
                vertices.push(...uniqueVertices);
                
                // Build faces using mapped indices
                for (let i = 0; i < pos.count; i += 3) {
                    const vA = new THREE.Vector3().fromBufferAttribute(pos, i);
                    const vB = new THREE.Vector3().fromBufferAttribute(pos, i + 1);
                    const vC = new THREE.Vector3().fromBufferAttribute(pos, i + 2);
                    
                    const keyA = `${vA.x.toFixed(8)}_${vA.y.toFixed(8)}_${vA.z.toFixed(8)}`;
                    const keyB = `${vB.x.toFixed(8)}_${vB.y.toFixed(8)}_${vB.z.toFixed(8)}`;
                    const keyC = `${vC.x.toFixed(8)}_${vC.y.toFixed(8)}_${vC.z.toFixed(8)}`;
                    
                    faces.push({ 
                        a: vertexMap.get(keyA), 
                        b: vertexMap.get(keyB), 
                        c: vertexMap.get(keyC) 
                    });
                }
                
                console.log('Merged', pos.count, 'vertices into', vertices.length, 'unique vertices');
            }

            // Face centroids
            const centroids = faces.map(f => new THREE.Vector3().add(vertices[f.a]).add(vertices[f.b]).add(vertices[f.c]).divideScalar(3).normalize().multiplyScalar(radius * 1.0005));

            const key = v => `${v.x.toFixed(6)}_${v.y.toFixed(6)}_${v.z.toFixed(6)}`;
            const edgeToFaces = new Map();
            faces.forEach((f, idx) => {
                [[f.a, f.b], [f.b, f.c], [f.c, f.a]].forEach(([iA, iB]) => {
                    const k1 = key(vertices[iA]); const k2 = key(vertices[iB]);
                    const ek = k1 < k2 ? `${k1}|${k2}` : `${k2}|${k1}`;
                    if (!edgeToFaces.has(ek)) edgeToFaces.set(ek, []);
                    edgeToFaces.get(ek).push(idx);
                });
            });

            const linePoints = [];
            for (const pair of edgeToFaces.values()) {
                if (pair.length === 2) {
                    linePoints.push(centroids[pair[0]].clone(), centroids[pair[1]].clone());
                }
            }

            const wireGeom = new THREE.BufferGeometry().setFromPoints(linePoints);
            const wireMat = new THREE.LineBasicMaterial({ color: 0x333333, linewidth: 1, transparent: true, opacity: 0.1 });
            wireframe = new THREE.LineSegments(wireGeom, wireMat);
            // wireframe will be added AFTER tiles so it sits on top with translucency

            // Dispose original geom (we cloned for solid)
            geom.dispose();

            // Build filled tiles with biome colors (simple triangular faces)
            tileGroup = new THREE.Group();
            // debug counts
            let countOcean = 0, countLand = 0, countIce = 0, countDesert = 0, countTotal = 0;

            // Continents seeds
            const rng = makeRng(settings.seed);
            const seeds = Array.from({length: settings.continents}, () => randomUnitVector(rng));
            const wind = new THREE.Vector3(0.7, 0.0, -0.3).normalize();

            function elevationAt(n) {
                // Base plate distance (nearest seed), 0..1
                let minD = 2;
                for (const s of seeds) { const d = 1 - n.dot(s); if (d < minD) minD = d; }
                let base = 1 - (minD / 2); // closer to a seed => higher
                base = Math.pow(base, 1.35); // sharpen continental shelves

                // fBm noise: frequency tied to noiseAmp for stronger visual impact
                const freq = 1.8 + settings.noiseAmp * 1.2;
                const detailNoise = fbm(n, freq, 4); // 0..1
                // Center noise around 0 and scale by noiseAmp
                const noiseTerm = (detailNoise - 0.5) * (0.9 * settings.noiseAmp);

                // Enhanced mountain ridge system
                let ridgeTerm = 0;
                if (settings.ridgeIntensity > 0) {
                    // Primary ridge lines - sharp mountain ranges
                    const ridge1 = Math.abs(fbm(n, 2.8, 3) - 0.5) * 2.0; // 0..1
                    const ridge2 = Math.abs(fbm(n.clone().multiplyScalar(1.7), 3.2, 3) - 0.5) * 2.0;
                    const ridge3 = Math.abs(fbm(n.clone().multiplyScalar(0.6), 4.1, 2) - 0.5) * 2.0;
                    
                    // Combine ridges with different weights
                    const ridgePattern = (ridge1 * 0.6 + ridge2 * 0.3 + ridge3 * 0.1);
                    
                    // Only create ridges on land areas (higher base elevation)
                    const landMask = Math.max(0, Math.min(1, (base - 0.3) * 2.0));
                    
                    // Sharp ridge peaks with valleys
                    const sharpRidge = Math.pow(ridgePattern, 0.8);
                    ridgeTerm = sharpRidge * settings.ridgeIntensity * landMask * 0.4;
                }

                let h = base * 0.85 + noiseTerm + ridgeTerm;
                // Normalize and clamp
                return Math.max(0, Math.min(1, h));
            }

            console.log('Total vertices:', vertices.length, 'Total faces:', faces.length);
            let tilesCreated = 0;
            
            // Build vertex-to-faces mapping for dual polyhedron (hexagons/pentagons)
            const vertexToFaces = new Map();
            faces.forEach((face, faceIndex) => {
                [face.a, face.b, face.c].forEach(vi => {
                    if (!vertexToFaces.has(vi)) vertexToFaces.set(vi, []);
                    vertexToFaces.get(vi).push(faceIndex);
                });
            });
            console.log('vertexToFaces map size:', vertexToFaces.size);
            const adjacencyCounts = Array.from(vertexToFaces.values()).map(faces => faces.length);
            console.log('Adjacent face counts - min:', Math.min(...adjacencyCounts), 'max:', Math.max(...adjacencyCounts), 'avg:', adjacencyCounts.reduce((a,b)=>a+b)/adjacencyCounts.length);
            
            // Pre-calculate elevation for all vertices
            const vertexElevations = vertices.map(v => {
                const normalized = v.clone().normalize();
                const elev = elevationAt(normalized);
                let extrude = (elev - settings.seaLevel);
                extrude = Math.max(-0.03, Math.min(0.08, extrude * 0.18));
                return 1.0 + extrude;
            });
            
            // Create hexagonal/pentagonal tiles using dual polyhedron approach
            let skippedCount = 0;
            vertices.forEach((vertex, vi) => {
                const adj = vertexToFaces.get(vi) || [];
                if (adj.length < 1) { 
                    skippedCount++;
                    return; // need at least 1 face
                }
                
                const center = vertex.clone().normalize();
                const elev = elevationAt(center);
                const shell = vertexElevations[vi];
                
                // Get face centroids that surround this vertex
                const faceCentroids = adj.map(faceIdx => {
                    const face = faces[faceIdx];
            const vA = vertices[face.a];
            const vB = vertices[face.b];
            const vC = vertices[face.c];
                    return new THREE.Vector3().add(vA).add(vB).add(vC).divideScalar(3).normalize();
                });
                
                // Sort face centroids by angle around the vertex to create proper polygon
                const up = center.clone();
                let right = new THREE.Vector3(1,0,0).cross(up).normalize();
                if (right.length() < 0.1) right = new THREE.Vector3(0,1,0).cross(up).normalize();
                const forward = up.clone().cross(right).normalize();
                
                const sortedCentroids = faceCentroids.map((c, i) => ({ centroid: c, index: i }))
                    .sort((a, b) => {
                        const vecA = a.centroid.clone().sub(center).normalize();
                        const vecB = b.centroid.clone().sub(center).normalize();
                        const angA = Math.atan2(vecA.dot(forward), vecA.dot(right));
                        const angB = Math.atan2(vecB.dot(forward), vecB.dot(right));
                        return angA - angB;
                    });
                
                // Create polygon (hexagon for most vertices, pentagon for 12 vertices)
                const boundary = sortedCentroids.map(s => s.centroid.clone().normalize());
                
                // Build triangle fan from center to boundary points with consistent elevation
                const pos = [];
                const nrm = [];
                const centerPos = center.clone().multiplyScalar(radius * shell);
                
                // Calculate boundary point elevations based on their vertex positions
                const boundaryElevations = boundary.map(boundaryPoint => {
                    // Find the closest vertex index for this boundary point
                    let closestVertexIdx = 0;
                    let minDist = Infinity;
                    for (let vi = 0; vi < vertices.length; vi++) {
                        const dist = boundaryPoint.distanceTo(vertices[vi].clone().normalize());
                        if (dist < minDist) {
                            minDist = dist;
                            closestVertexIdx = vi;
                        }
                    }
                    return vertexElevations[closestVertexIdx];
                });
                
                // Calculate smoothed normals for boundary vertices by averaging with neighbors
                const smoothedBoundaryNormals = boundary.map((boundaryPoint, idx) => {
                    // Start with the base normal pointing outward from sphere center
                    const baseNormal = boundaryPoint.clone().normalize();
                    
                    // Find nearby vertices and average their normals for smoothing
                    let avgNormal = baseNormal.clone();
                    let count = 1;
                    
                    for (let vi = 0; vi < vertices.length; vi++) {
                        const dist = boundaryPoint.distanceTo(vertices[vi].clone().normalize());
                        if (dist < 0.1) { // Close enough to influence normal
                            avgNormal.add(vertices[vi].clone().normalize());
                            count++;
                        }
                    }
                    
                    return avgNormal.divideScalar(count).normalize();
                });
                
                // Keep tiles sharp - simple triangle fan
                for (let i = 0; i < boundary.length; i++) {
                    const P = boundary[i].clone().multiplyScalar(radius * boundaryElevations[i]);
                    const N = boundary[(i + 1) % boundary.length].clone().multiplyScalar(radius * boundaryElevations[(i + 1) % boundary.length]);
                    
                    // Triangle: center -> P -> N
                    pos.push(centerPos.x, centerPos.y, centerPos.z);
                    pos.push(P.x, P.y, P.z);
                    pos.push(N.x, N.y, N.z);
                    
                    // Use smoothed normals for better lighting transitions
                    const centerNormal = centerPos.clone().normalize();
                    const pNormal = smoothedBoundaryNormals[i];
                    const nNormal = smoothedBoundaryNormals[(i + 1) % boundary.length];
                    
                    nrm.push(centerNormal.x, centerNormal.y, centerNormal.z);
                    nrm.push(pNormal.x, pNormal.y, pNormal.z);
                    nrm.push(nNormal.x, nNormal.y, nNormal.z);
                }
                
                const g = new THREE.BufferGeometry();
                g.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
                g.setAttribute('normal', new THREE.Float32BufferAttribute(nrm, 3));
                
                // Smooth biome coloring with transitions
                const isOcean = elev < settings.seaLevel;
                let tileColor;
                if (isOcean) {
                    // Ocean depth gradient
                    const depth = (settings.seaLevel - elev) / settings.seaLevel;
                    const deepBlue = { r: 0x00, g: 0x33, b: 0x99 };
                    const shallowBlue = { r: 0x44, g: 0x88, b: 0xFF };
                    const r = Math.floor(deepBlue.r + (shallowBlue.r - deepBlue.r) * (1 - depth));
                    const g = Math.floor(deepBlue.g + (shallowBlue.g - deepBlue.g) * (1 - depth));
                    const b = Math.floor(deepBlue.b + (shallowBlue.b - deepBlue.b) * (1 - depth));
                    tileColor = (r << 16) | (g << 8) | b;
                    countOcean++;
                } else {
                    const lat = Math.abs(center.y);
                    let temp = 1 - Math.pow(lat, 1.25) - elev*0.5;
                    temp = Math.max(0, Math.min(1, temp));
                    const moist = Math.max(0, Math.min(1, 0.55*fbm(center, 1.8, 3) + 0.45*Math.max(0, center.dot(wind))))
                                   * (0.9 + 0.3*(1-elev));
                    
                    // Define biome colors
                    const ice = { r: 0xFF, g: 0xFF, b: 0xFF };      // white
                    const desert = { r: 0xFF, g: 0x88, b: 0x33 };   // orange
                    const grassland = { r: 0x88, g: 0xCC, b: 0x44 }; // light green
                    const forest = { r: 0x22, g: 0x88, b: 0x22 };   // dark green
                    const mountain = { r: 0x77, g: 0x55, b: 0x33 }; // brown
                    const highMountain = { r: 0x99, g: 0x77, b: 0x55 }; // lighter brown for peaks
                    const ridgePeak = { r: 0xAA, g: 0xAA, b: 0xAA }; // rocky gray for highest ridges
                    
                    let finalColor = grassland; // default
                    
                    // High elevation = mountains/ice with enhanced ridge coloring
                    if (elev > settings.seaLevel + 0.35) {
                        const heightFactor = Math.min(1, (elev - settings.seaLevel - 0.35) / 0.15);
                        const veryHighElevation = elev > settings.seaLevel + 0.5;
                        
                        if (temp < 0.3) {
                            // Ice on high peaks
                            finalColor = {
                                r: Math.floor(mountain.r + (ice.r - mountain.r) * heightFactor),
                                g: Math.floor(mountain.g + (ice.g - mountain.g) * heightFactor),
                                b: Math.floor(mountain.b + (ice.b - mountain.b) * heightFactor)
                            };
                            if (heightFactor > 0.5) countIce++; else countLand++;
                        } else {
                            // Mountain ranges with different colors based on height
                            if (veryHighElevation && heightFactor > 0.7) {
                                // Highest peaks get rocky gray color
                                const peakFactor = (heightFactor - 0.7) / 0.3;
                                finalColor = {
                                    r: Math.floor(highMountain.r + (ridgePeak.r - highMountain.r) * peakFactor),
                                    g: Math.floor(highMountain.g + (ridgePeak.g - highMountain.g) * peakFactor),
                                    b: Math.floor(highMountain.b + (ridgePeak.b - highMountain.b) * peakFactor)
                                };
                            } else if (heightFactor > 0.4) {
                                // High mountains get lighter brown
                                const midFactor = (heightFactor - 0.4) / 0.3;
                                finalColor = {
                                    r: Math.floor(mountain.r + (highMountain.r - mountain.r) * midFactor),
                                    g: Math.floor(mountain.g + (highMountain.g - mountain.g) * midFactor),
                                    b: Math.floor(mountain.b + (highMountain.b - mountain.b) * midFactor)
                                };
                            } else {
                                // Lower mountains keep basic brown
                                finalColor = mountain;
                            }
                            countLand++;
                        }
                    }
                    // Cold regions = ice transition
                    else if (temp < 0.2) {
                        const coldFactor = 1 - (temp / 0.2);
                        finalColor = {
                            r: Math.floor(grassland.r + (ice.r - grassland.r) * coldFactor),
                            g: Math.floor(grassland.g + (ice.g - grassland.g) * coldFactor),
                            b: Math.floor(grassland.b + (ice.b - grassland.b) * coldFactor)
                        };
                        if (coldFactor > 0.6) countIce++; else countLand++;
                    }
                    // Hot and dry = desert
                    else if (moist < 0.3 && temp > 0.4) {
                        const dryFactor = Math.min(1, (0.3 - moist) / 0.3 * (temp - 0.4) / 0.6);
                        finalColor = {
                            r: Math.floor(grassland.r + (desert.r - grassland.r) * dryFactor),
                            g: Math.floor(grassland.g + (desert.g - grassland.g) * dryFactor),
                            b: Math.floor(grassland.b + (desert.b - grassland.b) * dryFactor)
                        };
                        if (dryFactor > 0.5) countDesert++; else countLand++;
                    }
                    // Wet regions = forest
                    else if (moist > 0.6) {
                        const wetFactor = Math.min(1, (moist - 0.6) / 0.4);
                        finalColor = {
                            r: Math.floor(grassland.r + (forest.r - grassland.r) * wetFactor),
                            g: Math.floor(grassland.g + (forest.g - grassland.g) * wetFactor),
                            b: Math.floor(grassland.b + (forest.b - grassland.b) * wetFactor)
                        };
                        countLand++;
                    }
                    else {
                        countLand++;
                    }
                    
                    tileColor = (finalColor.r << 16) | (finalColor.g << 8) | finalColor.b;
                }
                countTotal++;
                tilesCreated++;
                
                // Create solid triangle tile
                // Use Phong material for smoother lighting and better edge interpolation
                const mat = new THREE.MeshPhongMaterial({ 
                    color: tileColor, 
                    transparent: false,
                    opacity: 1.0,
                    side: THREE.DoubleSide,
                    shininess: 10,
                    specular: 0x111111
                });
                const m = new THREE.Mesh(g, mat);
                
                // Store original color for hover system
                m.userData.originalColor = tileColor;
                m.userData.tileId = vi; // unique tile identifier
                m.userData.isTile = true; // mark as hoverable tile
                
                tileGroup.add(m);

                // Add rounded corner highlighting outline
                const outlinePos = [];
                const cornerRadius = 0.08; // Radius for rounded corners
                const cornerSegments = 3; // Segments per rounded corner
                
                for (let i = 0; i < boundary.length; i++) {
                    const current = boundary[i].clone().multiplyScalar(radius * boundaryElevations[i]);
                    const next = boundary[(i + 1) % boundary.length].clone().multiplyScalar(radius * boundaryElevations[(i + 1) % boundary.length]);
                    const prev = boundary[(i - 1 + boundary.length) % boundary.length].clone().multiplyScalar(radius * boundaryElevations[(i - 1 + boundary.length) % boundary.length]);
                    
                    // Calculate vectors for corner rounding
                    const toPrev = prev.clone().sub(current).normalize();
                    const toNext = next.clone().sub(current).normalize();
                    
                    // Create rounded corner
                    const cornerStart = current.clone().add(toPrev.clone().multiplyScalar(cornerRadius));
                    const cornerEnd = current.clone().add(toNext.clone().multiplyScalar(cornerRadius));
                    
                    // Add corner start point
                    outlinePos.push(cornerStart.x, cornerStart.y, cornerStart.z);
                    
                    // Add rounded corner points
                    for (let j = 1; j <= cornerSegments; j++) {
                        const t = j / (cornerSegments + 1);
                        const cornerPoint = cornerStart.clone().lerp(cornerEnd, t);
                        // Curve the corner slightly
                        const curvedPoint = cornerPoint.clone().lerp(current, 0.2 * Math.sin(t * Math.PI));
                        outlinePos.push(curvedPoint.x, curvedPoint.y, curvedPoint.z);
                    }
                    
                    // Add corner end point
                    outlinePos.push(cornerEnd.x, cornerEnd.y, cornerEnd.z);
                }
                
                // Close the loop back to first point
                if (outlinePos.length > 0) {
                    outlinePos.push(outlinePos[0], outlinePos[1], outlinePos[2]);
                }
                
                const outlineGeom = new THREE.BufferGeometry();
                outlineGeom.setAttribute('position', new THREE.Float32BufferAttribute(outlinePos, 3));
                const outlineMat = new THREE.LineBasicMaterial({ 
                    color: 0x000000, // black borders
                    linewidth: 2,
                    transparent: true,
                    opacity: settings.outlineAlpha
                });
                const outline = new THREE.Line(outlineGeom, outlineMat);
                tileGroup.add(outline);
            });
            scene.add(tileGroup);
            console.log(`Created ${tilesCreated} tiles, counted ${countTotal} biomes, skipped ${skippedCount} vertices`);
            // update debug label with nice formatting
            const lbl = document.getElementById('seedLbl');
            if (lbl) {
                lbl.innerHTML = `
                    <div style="font-size: 11px; line-height: 1.3;">
                        <div><strong>Seed:</strong> ${settings.seed}</div>
                        <div><strong>Tiles:</strong> ${countTotal}</div>
                        <div style="margin-top: 2px;">
                            <span style="color: #0066FF;">Ocean: ${countOcean}</span> | 
                            <span style="color: #00CC00;">Land: ${countLand}</span>
                        </div>
                        <div>
                            <span style="color: #FFFFFF; background: #666; padding: 0 2px;">Ice: ${countIce}</span> | 
                            <span style="color: #FF6600;">Desert: ${countDesert}</span>
                        </div>
                    </div>
                `;
            }
            // No wireframe needed - tiles have their own borders
            
            // Create cloud layer
            createCloudSphere();
        }

        // UI
        const detailSlider = document.getElementById('detail');
        const detailValue = document.getElementById('detailValue');
        const continentsSlider = document.getElementById('continents');
        const continentsValue = document.getElementById('continentsValue');
        const seaSlider = document.getElementById('sea');
        const seaValue = document.getElementById('seaValue');
        const noiseSlider = document.getElementById('noise');
        const noiseValue = document.getElementById('noiseValue');
        const ridgesSlider = document.getElementById('ridges');
        const ridgesValue = document.getElementById('ridgesValue');
        const alphaSlider = document.getElementById('alpha');
        const alphaValue = document.getElementById('alphaValue');
        const cloudDensitySlider = document.getElementById('cloudDensity');
        const cloudDensityValue = document.getElementById('cloudDensityValue');
        const cloudOpacitySlider = document.getElementById('cloudOpacity');
        const cloudOpacityValue = document.getElementById('cloudOpacityValue');
        const regenBtn = document.getElementById('regen');

        function setDetail(val) {
            detailValue.textContent = val;
            lastDetail = parseInt(val,10);
            console.log('detail changed ->', lastDetail);
            buildPlanet(lastDetail);
        }
        function updateAndRebuild(reason) {
            if (reason) console.log('rebuild reason:', reason);
            setSeedLabel();
            buildPlanet(lastDetail);
        }

        detailSlider.addEventListener('input', e => setDetail(e.target.value));
        detailSlider.addEventListener('change', e => setDetail(e.target.value));

        function onContinents(val) {
            settings.continents = parseInt(val,10);
            continentsValue.textContent = settings.continents;
            updateAndRebuild('continents');
        }
        function onSea(val) {
            settings.seaLevel = parseFloat(val);
            seaValue.textContent = settings.seaLevel.toFixed(2);
            updateAndRebuild('sea');
        }
        function onNoise(val) {
            settings.noiseAmp = parseFloat(val);
            noiseValue.textContent = settings.noiseAmp.toFixed(2);
            updateAndRebuild('noise');
        }
        function onRidges(val) {
            settings.ridgeIntensity = parseFloat(val);
            ridgesValue.textContent = settings.ridgeIntensity.toFixed(2);
            updateAndRebuild('ridges');
        }
        function onAlpha(val) {
            settings.outlineAlpha = parseFloat(val);
            alphaValue.textContent = settings.outlineAlpha.toFixed(2);
            updateAndRebuild('alpha');
        }
        function onCloudDensity(val) {
            settings.cloudDensity = parseFloat(val);
            cloudDensityValue.textContent = settings.cloudDensity.toFixed(2);
            updateCloudSettings();
        }
        function onCloudOpacity(val) {
            settings.cloudOpacity = parseFloat(val);
            cloudOpacityValue.textContent = settings.cloudOpacity.toFixed(2);
            updateCloudSettings();
        }
        
        function updateCloudSettings() {
            if (cloudSphere && cloudSphere.material && cloudSphere.material.uniforms) {
                cloudSphere.material.uniforms.cloudDensity.value = settings.cloudDensity;
                cloudSphere.material.uniforms.cloudOpacity.value = settings.cloudOpacity;
                
                // If clouds are turned off, remove them entirely
                if (settings.cloudDensity <= 0 || settings.cloudOpacity <= 0) {
                    disposeObject(cloudSphere);
                    cloudSphere = null;
                } else if (!cloudSphere) {
                    // If clouds were off but now turned on, recreate them
                    createCloudSphere();
                }
            } else if (settings.cloudDensity > 0 && settings.cloudOpacity > 0) {
                // Create clouds if they don't exist but should
                createCloudSphere();
            }
        }

        continentsSlider.addEventListener('input', e => onContinents(e.target.value));
        continentsSlider.addEventListener('change', e => onContinents(e.target.value));
        seaSlider.addEventListener('input', e => onSea(e.target.value));
        seaSlider.addEventListener('change', e => onSea(e.target.value));
        noiseSlider.addEventListener('input', e => onNoise(e.target.value));
        noiseSlider.addEventListener('change', e => onNoise(e.target.value));
        ridgesSlider.addEventListener('input', e => onRidges(e.target.value));
        ridgesSlider.addEventListener('change', e => onRidges(e.target.value));
        alphaSlider.addEventListener('input', e => onAlpha(e.target.value));
        alphaSlider.addEventListener('change', e => onAlpha(e.target.value));
        cloudDensitySlider.addEventListener('input', e => onCloudDensity(e.target.value));
        cloudDensitySlider.addEventListener('change', e => onCloudDensity(e.target.value));
        cloudOpacitySlider.addEventListener('input', e => onCloudOpacity(e.target.value));
        cloudOpacitySlider.addEventListener('change', e => onCloudOpacity(e.target.value));
        regenBtn.addEventListener('click', ()=>{ settings.seed = Math.floor(Math.random()*1e9); updateAndRebuild('regen'); });

        // Initial
        setSeedLabel();
        setDetail(detailSlider.value);

        // Resize
        // Mouse hover functionality
        function onMouseMove(event) {
            // Calculate mouse position in normalized device coordinates (-1 to +1)
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Update raycaster
            raycaster.setFromCamera(mouse, camera);
            
            if (tileGroup) {
                // Filter to only tile meshes (not outlines)
                const tileMeshes = tileGroup.children.filter(child => 
                    child.userData && child.userData.isTile === true
                );
                
                // Find intersections with tile meshes only
                const intersects = raycaster.intersectObjects(tileMeshes, false);
                
                // Reset previous hover
                if (hoveredTile) {
                    hoveredTile.material.color.setHex(hoveredTile.userData.originalColor);
                    hoveredTile = null;
                }
                
                // Apply new hover - find the closest tile intersection
                if (intersects.length > 0) {
                    // Sort by distance and take the closest
                    intersects.sort((a, b) => a.distance - b.distance);
                    
                    for (let i = 0; i < intersects.length; i++) {
                        const tile = intersects[i].object;
                        if (tile.userData && tile.userData.isTile && tile.userData.originalColor !== undefined) {
                            hoveredTile = tile;
                            // Bright yellow highlight
                            tile.material.color.setHex(0xFFFF00);
                            break;
                        }
                    }
                }
            }
        }
        
        // Add mouse event listener
        renderer.domElement.addEventListener('mousemove', onMouseMove, false);
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Animate
        (function animate() {
            requestAnimationFrame(animate);
            controls.update();
            
            // Update cloud animation
            cloudAnimationTime += 0.01;
            if (cloudSphere && cloudSphere.material && cloudSphere.material.uniforms) {
                cloudSphere.material.uniforms.time.value = cloudAnimationTime;
            }
            
            renderer.render(scene, camera);
        })();
    </script>
</body>
</html>

